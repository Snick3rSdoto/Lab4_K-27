# Звіт до лабораторної роботи 
Виконав студент групи К-27 Тарасенко Максим 

## Умова задачі (специфічна для варіанту)

Необхідно розробити структуру даних для багатопотокової програми, що складається з \(m = 2\) цілих полів, які можна незалежно читати та змінювати. Для кожного поля мають бути реалізовані операції добування (read) та встановлення (write) значення, а для структури в цілому — перевантажений `operator std::string()`, що повертає рядкове подання всіх полів.  

Для заданого варіанту визначено такі частоти операцій:

- Для поля **0**: запис — **5 %**, читання — **40 %**  
- Для поля **1**: запис — **5 %**, читання — **5 %**  
- Операція формування рядка (`string`) — **45 %** від загальної кількості операцій зі структурою даних.

---

## Схема захисту даних та її обґрунтування

У структурі використано **два м’ютекси**: `m0` захищає поле `f0`, а `m1` — поле `f1`. Операції читання і запису блокують лише відповідний м’ютекс, що зменшує конкуренцію між потоками. Оператор `operator std::string()` блокує обидва м’ютекси одночасно через `std::scoped_lock`, щоб гарантовано отримати узгоджений стан обох полів. Така схема вибрана як оптимальна: мінімізує блокування для частих операцій читання, але забезпечує коректність для операції формування рядка, яка має найбільшу частку у загальному розподілі.

---

## Табличка усереднених результатів виконання (3×3)

| Сценарій / Потоки | 1 потік (мс) | 2 потоки (мс) | 3 потоки (мс) |
|-------------------|--------------|---------------|---------------|
| A (за варіантом)  | 52.8         | 180.8         | 401.8         |
| B (рівномірний)   | 32.0         | 108.4         | 226.4         |
| C (невідповідний) | 30.2         | 104.6         | 221.0         |

---

## Висновки

Результати показали, що збільшення кількості потоків **не прискорює**, а навпаки — сповільнює виконання програми в усіх сценаріях. Основна причина — конкуренція потоків за м’ютекси та значні накладні витрати синхронізації при частій операції `string`. У сценаріях з іншим розподілом операцій (B і C) часи трохи кращі, але тенденція зростання часу при переході до 2–3 потоків зберігається. Це підтверджує, що для коротких частих операцій з синхронізацією багатопотоковість може не давати виграшу, а інколи навіть знижує продуктивність.
У підсумку експеримент демонструє важливий практичний висновок: для структур даних із дуже частими короткими, але синхронізованими операціями багатопотоковість не завжди дає виграш у продуктивності й може навіть погіршувати час виконання, якщо схема синхронізації є «вузьким місцем».

<img width="1036" height="782" alt="image" src="https://github.com/user-attachments/assets/f2fd0e64-f75d-4e42-9ccc-a399abd754d7" />

